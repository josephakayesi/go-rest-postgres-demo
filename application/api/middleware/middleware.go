package middleware

import (
	"fmt"
	"strings"

	"github.com/gofiber/fiber/v2"

	vo "github.com/josephakayesi/go-cerbos-abac/domain/core/valueobject"
	infra "github.com/josephakayesi/go-cerbos-abac/infra/paseto"
)

func RequireIdempotencyKey(c *fiber.Ctx) error {
	idempotency_key := string(c.Context().Request.Header.Peek("idempotency_key"))
	if l, wl := len(idempotency_key), 36; l != wl {
		// errors because of idempotency should not be revealed to clients.
		// a generic message should be sent to clients to retry because by default;
		// idempotency keys are autogenerated on the client side
		return c.Status(401).JSON(map[string]string{"message": "idempotency key is required"})
	}

	return c.Status(401).JSON(map[string]string{"message": "idempotency key is required"})
}

func LoadAuthorizationMiddleware(roles ...vo.Role) func(*fiber.Ctx) error {
	return func(c *fiber.Ctx) error {
		token := c.Get("Authorization")

		tokenSplit := strings.Split(token, "Bearer ")

		if len(tokenSplit) != 2 {
			return c.Status(fiber.StatusUnauthorized).JSON(map[string]string{"message": "unauthorized to access this route"})
		}

		paseto := tokenSplit[1]

		payload, err := infra.LoadPaseto().VerifyAccessToken(paseto)
		fmt.Printf("payload %+v\n", payload)
		if err != nil {
			return c.Status(fiber.StatusUnauthorized).JSON(map[string]string{"message": "unauthorized to access this route"})
		}

		var isAuthorizedRole bool
		for _, role := range roles {
			if payload.Role == role {
				isAuthorizedRole = true
				break
			}
		}

		if !isAuthorizedRole {
			return c.Status(fiber.StatusUnauthorized).JSON(map[string]string{"message": "unauthorized to access this route"})
		}

		c.Locals("user", payload)

		return c.Next()
	}
}
